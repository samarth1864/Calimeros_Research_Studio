# -*- coding: utf-8 -*-
"""Calculating the compliance

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XdZEyBRb-sdPWwyvYBre2rIiNISHg3b9
"""

# Install required libraries
!pip install geopandas shapely matplotlib pandas numpy

# Import required libraries
import geopandas as gpd
from shapely.geometry import box
import numpy as np

# Define file paths
parks_file_path = '/content/parks_and_gardens_of_barcelona.geojson'
population_file_path = '/content/population_in_barcelona.geojson'

# Load parks and gardens data
gdf_parks = gpd.read_file(parks_file_path)

# Load population data as residential zones
gdf_population = gpd.read_file(population_file_path)

# Define CRS for projected coordinate system
projected_crs = "EPSG:25831"
gdf_parks = gdf_parks.to_crs(projected_crs)
gdf_population = gdf_population.to_crs(projected_crs)

# Filter parks with an area of at least 9 m²
gdf_parks["area_m2"] = gdf_parks.geometry.area
gdf_parks = gdf_parks[gdf_parks["area_m2"] >= 9]

# Use population data as residential areas
gdf_residential = gdf_population.copy()

# Generate a grid of 200x200 meter cells over Barcelona
grid_size = 200  # Grid cell size in meters
xmin_proj, ymin_proj, xmax_proj, ymax_proj = gdf_parks.total_bounds
x_coords = np.arange(xmin_proj, xmax_proj, grid_size)
y_coords = np.arange(ymin_proj, ymax_proj, grid_size)
grid_cells = [box(x, y, x + grid_size, y + grid_size) for x in x_coords for y in y_coords]
gdf_grid = gpd.GeoDataFrame(geometry=grid_cells, crs=projected_crs)

# Mask grid cells to include only areas within Barcelona's urban boundary
barcelona_boundary = gpd.GeoDataFrame(geometry=[gdf_residential.unary_union], crs=projected_crs)
gdf_grid = gdf_grid[gdf_grid.intersects(barcelona_boundary.geometry[0])]

# Create a buffer of 200 meters around residential areas
residential_buffer = gdf_residential.buffer(200)
residential_union = gpd.GeoDataFrame(geometry=[residential_buffer.unary_union], crs=projected_crs)

# Filter grid cells that intersect with the residential buffer
gdf_grid_residential = gdf_grid[gdf_grid.intersects(residential_union.geometry[0])]

# Check which grid cells have access to parks or gardens within 200 meters
gdf_grid_residential["has_access_to_park"] = gdf_grid_residential.geometry.apply(
    lambda cell: gdf_parks.geometry.intersects(cell).any()
)

# Calculate compliance: A cell is compliant if it has access to a park or garden within 200 meters
compliance_breakdown = gdf_grid_residential["has_access_to_park"].value_counts()

# Total cells and compliant cells
total_cells_residential = len(gdf_grid_residential)
compliant_cells = compliance_breakdown.get(True, 0)
non_compliant_cells = compliance_breakdown.get(False, 0)

# Calculate the area needed to make all non-compliant cells compliant
needed_area_per_cell = gdf_grid_residential["geometry"].area.mean()
needed_cells = non_compliant_cells
needed_area_total = needed_cells * needed_area_per_cell

# Print results
print("Total cells in residential areas:", total_cells_residential)
print("Compliant cells:", compliant_cells)
print("Non-compliant cells:", non_compliant_cells)
print("Needed area of parks and gardens to achieve 100% compliance (m²):", needed_area_total)

